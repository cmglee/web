<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     width="100%" height="100%" viewBox="-6 -9 512 768" onload="main(evt)">
 <title>Clone of Gimme Friction Baby</title>
 <desc>Clone of Gimme Friction Baby in SVG/ECMAScript by CMG Lee.</desc>
 <script type="text/ecmascript"><![CDATA[ /// so needn't use &lt; for < etc
  var delay           = 50;
  var speed_max       = 50;
  var speed_min       = 10;
  var n_grow_step     = 5;
  var disc_dasharrays = ['1,9', '7,9', 'none'];
  var control   = {mode:0}; /// 0=shooting, 1=stepping/growing, 2=dead
  var container = {};
  var overlay   = {};
  var gameover  = {};
  var score     = {};
  var arena     = {};
  var gun       = {};
  var shot      = {};
  var discs     = [];
  var deg2rad   = Math.PI / 180;
  var rad2deg   = 180 / Math.PI;
  /*
  var debug;
  function log() {
   var args = Array.prototype.slice.call(arguments, 0);
   debug.nodeValue = args.join('|');
   setTimeout(function() { throw(args.join('\t')); }, 0);
  }
  */
  function sind(deg) { return Math.sin(deg * deg2rad); }
  function cosd(deg) { return Math.cos(deg * deg2rad); }
  function atand(val) { return Math.atan(val) * rad2deg; }
  function atan2d(y,x) { return Math.atan2(y,x) * rad2deg; }
  function setAttributes(obj, attributes) {
   for (var attribute in attributes) {
    obj.setAttribute(attribute, attributes[attribute]);
   }
  }
  function createElement(type, attributes, parent) {
   var obj = document.createElementNS('http://www.w3.org/2000/svg', type);
   setAttributes(obj, attributes);
   if (parent) { parent.appendChild(obj); } else { container.obj.appendChild(obj); }
   return obj;
  }
  function removeElement(element) {
   var parent = element.parentNode;
   parent.removeChild(element);
   return parent;
  }
  function mousedown(evt) {
   control.x_down = evt.clientX;
   control.y_down = evt.clientY;
   control.obj.setAttribute('style', 'cursor:grabbing');
  }
  function mouseup(evt) {
   switch (control.mode) {
    case 0:
     control.mode = 1;
     control.x_up = evt.clientX;
     control.y_up = evt.clientY;
     shoot();
     break;
    case 2:
     restart();
     break;
   }
   control.obj.setAttribute('style', 'cursor:grab');
  }
  function init() {
   container.obj = document.getElementById('container');
   gameover.obj  = document.getElementById('gameover');
   overlay.obj   = document.getElementById('overlay');
   arena.obj     = document.getElementById('arena');
   arena.width   = arena.obj.getAttribute('width');
   arena.height  = arena.obj.getAttribute('height');
   /* debug = document.getElementById('debug').firstChild; */
   score.obj = document.getElementById('score');
   setAttributes(score.obj, {x:arena.width * 0.5, y:arena.height * 0.25});
   shot.obj = createElement('circle', {cx:0, cy:0, r:0, stroke:'none', fill:'url(#grad_shot)'});
   gun = {x:arena.width * 0.5, y:arena.height * 0.9, r:arena.width * 0.03, shot_size:arena.width * 0.02};
   gun.obj = document.getElementById('gun');
   setAttributes(gun.obj, {cx:gun.x, cy:gun.y, r:gun.r});
   control.obj = document.getElementById('control');
   control.obj.addEventListener('mouseup',   mouseup,   false);
   control.obj.addEventListener('mousedown', mousedown, false);
  }
  function update_score(value) {
   score.value = value;
   score.obj.firstChild.nodeValue = value;
  }
  function restart() {
   while (discs.length > 0) { remove_disc(discs.length - 1); }
   update_score(0);
   reset_shot();
   setAttributes(gameover.obj, {transform:'scale(1,0)'});
   control.mode = 0;
  }
  function make_disc() {
   var disc = {x:shot.x, y:shot.y, r:shot.r, life:disc_dasharrays.length - 1};
   disc.obj = createElement('circle', {cx:disc.x, cy:disc.y, r:disc.r, fill:'url(#grad_disc)'});
   discs.push(disc);
  }
  function remove_disc(i_disc) {
   removeElement(discs[i_disc].obj);
   discs.splice(i_disc, 1);
  }
  function bump_disc(i_disc) {
   var disc = discs[i_disc];
   if (disc.life > 0) {
    --disc.life;
    setAttributes(disc.obj, {'stroke-dasharray':disc_dasharrays[disc.life]});
   } else {
    remove_disc(i_disc);
    update_score(score.value + 1);
   }
  }
  function reset_shot() {
   shot = {x:gun.x, y:gun.y, r:gun.shot_size, obj:shot.obj};
   setAttributes(shot.obj, {cx:shot.x, cy:shot.y, r:shot.r});
  }
  function grow_animate(r, ttl) {
   if (ttl > 0) {
    shot.r = (shot.r + r) / 2;
    setAttributes(shot.obj, {r:shot.r});
    setTimeout(function() { grow_animate(r, ttl - 1) }, delay);
   } else {
    shot.r = r;
    setAttributes(shot.obj, {r:shot.r});
    make_disc();
    check_game_over();
   }
  }
  function grow() {
   /// Add distance to walls
   var distances = [shot.x, arena.width - shot.x, shot.y, arena.height - shot.y];
   /// Add distance to discs
   for (var i_disc = 0; i_disc < discs.length; ++i_disc) {
    var disc = discs[i_disc];
    var distance_x = disc.x - shot.x;
    var distance_y = disc.y - shot.y;
    distances.push(Math.sqrt(distance_x * distance_x + distance_y * distance_y) - disc.r);
   }
   distances.sort(function(a, b) { return a - b; });
   grow_animate(distances[0] - 1e-3, n_grow_step); /// -1e-3 avoids rounding error on immediate collision
  }
  function trace(start, start2end) {
   var end = {x: start.x + start2end.x, y: start.y + start2end.y};
   var intersects = new Array();
   var intersect, reflection; /// reflection is the vector from intersect to end
   /// Check if ray intersects any wall
   var arena_width_r = arena.width - shot.r;
   var arena_height_r = arena.height - shot.r;
   if (end.x < shot.r) {
    intersect = {x:shot.r, y:start.y - (start.x - shot.r) * (start.y - end.y) / (start.x - end.x)};
    reflection = {x:shot.r - end.x, y:end.y - intersect.y};
    intersects.push({t2:(intersect.y - start.y) / start2end.y, intersect:intersect, reflection:reflection, i_disc:-1});
   } else if (end.x > arena_width_r) {
    intersect = {x:arena_width_r, y:start.y - (start.x - arena_width_r) * (start.y - end.y) / (start.x - end.x)};
    reflection = {x:arena_width_r - end.x, y:end.y - intersect.y};
    intersects.push({t2:(intersect.y - start.y) / start2end.y, intersect:intersect, reflection:reflection, i_disc:-1});
   }
   if (end.y < shot.r) {
    intersect = {y:shot.r, x:start.x - (start.y - shot.r) * (start.x - end.x) / (start.y - end.y)};
    reflection = {y:shot.r - end.y, x:end.x - intersect.x};
    intersects.push({t2:(intersect.x - start.x) / start2end.x, intersect:intersect, reflection:reflection, i_disc:-1});
   } else if (end.y > arena_height_r) {
    intersect = {y:arena_height_r, x:start.x - (start.y - arena_height_r) * (start.x - end.x) / (start.y - end.y)};
    reflection = {y:arena_height_r - end.y, x:end.x - intersect.x};
    intersects.push({t2:(intersect.x - start.x) / start2end.x, intersect:intersect, reflection:reflection, i_disc:-1});
   }
   /// For each disc, check if ray intersects it,
   /// calculating reflection if so
   for (var i_disc = 0; i_disc < discs.length; ++i_disc) {
    var disc = discs[i_disc];
    var r_effective = disc.r + shot.r;
    /// Based on http://stackoverflow.com/questions/1073336/circle-line-collision-detection
    var disc2start = {x: disc.x - start.x, y: disc.y - start.y};
    var start2end_dot_start2end = start2end.x * start2end.x + start2end.y * start2end.y;
    var disc2start_dot_start2end = disc2start.x * start2end.x + disc2start.y * start2end.y;
    var disc2start_dot_disc2start = disc2start.x * disc2start.x + disc2start.y * disc2start.y;
    var a = start2end_dot_start2end;
    var b = disc2start_dot_start2end * 2;
    var c = disc2start_dot_disc2start - r_effective * r_effective;
    var discriminant = b * b - 4 * a * c;
    if (discriminant > 0) {
     var discriminant = Math.sqrt(discriminant);
     var t1 = (discriminant + b) / (-2 * a);
     var t2 = (discriminant - b) / (-2 * a);
     if (t2 >= 0 && t2 <= 1) {
      /// Based on http://math.stackexchange.com/questions/13261/how-to-get-a-reflection-vector
      intersect = {x:start.x + t2 * start2end.x,y:start.y + t2 * start2end.y};
      var end2intersect = {x: intersect.x - end.x, y: intersect.y - end.y};
      var tangent = {x: disc.y - intersect.y, y: intersect.x - disc.x};
      var tangent_magnitude = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y);
      tangent = {x: tangent.x / tangent_magnitude, y: tangent.y / tangent_magnitude};
      /// tangent is normal rotated through 90 degrees and normalised
      var end2intersect_dot_tangent_2 = (end2intersect.x * tangent.x + end2intersect.y * tangent.y) * 2;
      reflection = {x: end2intersect.x - end2intersect_dot_tangent_2 * tangent.x,
                    y: end2intersect.y - end2intersect_dot_tangent_2 * tangent.y};
      intersects.push({t2:t2, intersect:intersect, reflection:reflection, i_disc:i_disc});
     }
    }
   }
   /// If it has intersected anything, reflect off the nearest
   if (intersects.length) {
    intersects.sort(function(a, b) { return a.t2 - b.t2; });
    if (intersects[0].i_disc >= 0) { bump_disc(intersects[0].i_disc); }
    return trace(intersects[0].intersect, intersects[0].reflection);
   } else {
    return {position:end, velocity:start2end};
   }
  }
  function step(bearing, speed, friction) {
   var next = trace(shot, {x: speed * sind(bearing), y: speed * -cosd(bearing)});
   shot.x = next.position.x;
   shot.y = next.position.y;
   setAttributes(shot.obj, {cx:shot.x, cy:shot.y});
   if (speed > friction) {
    next_bearing = atan2d(next.velocity.x, -next.velocity.y);
    setTimeout(function() { step(next_bearing, speed - friction, friction); }, delay);
   } else {
    setTimeout(function() { grow(); }, delay);
   }
  }
  function shoot() {
   var dx      = control.x_up - control.x_down;
   var dy      = control.y_up - control.y_down;
   var bearing = atan2d(dx, -dy);
   var speed   = Math.sqrt(dx * dx + dy * dy) * arena.width / window.innerWidth;
   // console.log(dx, dy, bearing, speed, speed_min, speed_max);
   if (speed < speed_min) { speed = speed_min; }
   if (speed > speed_max) { speed = speed_max; }
   step(bearing, speed, 1);
  }
  function game_over_animate(scale) {
   setAttributes(gameover.obj, {transform:'scale(1,' + scale + ')'});
   if (scale < 4) { setTimeout(function() { game_over_animate(scale + 0.5); }, delay); }
  }
  function check_game_over() {
   for (var i_disc = 0; i_disc < discs.length; ++i_disc) {
    var disc = discs[i_disc];
    var distance_x = disc.x - gun.x;
    var distance_y = disc.y - gun.y;
    if (Math.sqrt(distance_x * distance_x + distance_y * distance_y) - disc.r < gun.r) {
     /// Game over
     control.mode = 2;
     control.obj.setAttribute('style', 'cursor:default');
     game_over_animate(0);
     return;
    }
   }
   /// Not game over
   reset_shot();
   control.mode = 0;
  }
  function main(evt) {
   init();
   restart();
  }
 ]]></script>
 <defs>
  <radialGradient id="grad_shot" cx="50%" cy="50%" r="50%" fx="50%" fy="25%">
   <stop offset="10%"  stop-color="#ffffff"/>
   <stop offset="100%" stop-color="#666666"/>
  </radialGradient>
  <radialGradient id="grad_disc" cx="50%" cy="50%" r="50%" fx="50%" fy="25%">
   <stop offset="10%"  stop-color="#ffffff"/>
   <stop offset="100%" stop-color="#66ccff"/>
  </radialGradient>
  <radialGradient id="grad_gun" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
   <stop offset="0%"   stop-color="#ffff00" stop-opacity="0"/>
   <stop offset="100%" stop-color="#00cc00" stop-opacity="1"/>
  </radialGradient>
  <radialGradient id="grad_gameover" cx="50%" cy="50%" r="75%" fx="50%" fy="50%">
   <stop offset="0%"   stop-color="#ff0000" stop-opacity="0"/>
   <stop offset="100%" stop-color="#660000" stop-opacity="0.75"/>
  </radialGradient>
  <rect id="all" x="-4999" y="-4999" width="9999" height="9999"/>
 </defs>
 <use xlink:href="#all" fill="#333333"/>
 <g id="container" stroke="#0066cc" stroke-width="2" stroke-linecap="round">
  <rect id="arena" x="0" y="0" rx="5" ry="5" width="500" height="750" stroke="#000000" fill="#ffffff"/>
 </g>
 <g id="overlay" stroke="none" fill="#000000" fill-opacity="0.5">
  <circle id="gun" cx="0" cy="0" r="0" stroke="none" fill="url(#grad_gun)"/>
  <text id="score" x="0" y="0" text-anchor="middle" font-family="serif" font-size="200" letter-spacing="-10">&#160;</text>
  <!--
  <text id="debug" x="0" y="20" text-anchor="start" font-family="sans-serif" font-size="20">&#160;</text>
  -->
 </g>
 <path id="gameover" d="M 0 0 H 500 V 300 C 500 500 400 500 400 300 C 400 200 300 200 300 300 C 300 400 200 400 200 300 C 200 250 100 250 100 300 C 100 550 0 550 0 300 Z" fill="#ff0000" fill-opacity="0.5"/>
 <!-- control must be topmost; fill is irrelevant but must exist -->
 <use id="control" xlink:href="#all" fill="#ffffff" fill-opacity="0" cursor="grab"/>
</svg>
